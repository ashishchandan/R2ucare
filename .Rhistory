deja[ii] = deja[ii] + when[ii,jj] # number of reobservations
if (deja[ii]>1) when[ii,jj] = 0 # if already seen again, neglect observation
} # loop on jj (remaining occasions)
} # loop on ii (selected individuals)
# end calculation of next recapture
effj = freq[ind] # works if eff is a columnn
aeffj = abs(effj) # handles negative numbers (if seen again after j)
newORold[,1] = (before[ind]>0)*aeffj # numbers of old by rh (nj x 2)
newORold[,2] = (before[ind]==0)*aeffj # numbers of new by rh
cont_tab = t(newORold) %*% when # (2 x nj by nj x K-j i.e. 2 by K-j
cont_tab = pool2K(cont_tab,2) # pool if needed
ML = apply(cont_tab,2,sum)
MC = apply(cont_tab,1,sum)
# calculate df
if (any(as.logical(cont_tab))){ # non empty table
df = (sum(ML>0)-1)*(sum(MC>0)-1) # takes account of empty rows and columns
} else {
df=0 # empty table
}
# end of df calculation
if (df>0) {
U = ind_test_rc(cont_tab,2)
} else {
U = c(0,0,0,'None')
}
} # if (nj > 0)
result[i,2] = U[1] # stat chi-square (also if Fisher performed)
result[i,3] = U[3] # degree of freedom
result[i,4] = U[2] # p-value of chi-square/Fisher
result[i,5] = U[4] # chi-square/Fisher
} # for (j in it3)
# compute overall test:
stat = sum(as.numeric(result[,2]))
stat = round(stat,rounding)
dof = sum(as.numeric(result[,3]))
rounding=3
n = dim(X)[1]
K = dim(X)[2]
result = data.frame(component = rep(NA,K-2),stat = rep(NA,K-2), df = rep(NA,K-2), p_val = rep(NA,K-2), test_perf = rep(FALSE,K-2))
it3 = 2:(K-1) # occasions of capture 2:K-1
before = rep(0,n) # nr of captures before 1
after = apply(X,1,sum)-X[,1] # nr of captures after 1
i = 0
for (j in it3){ # scan occasions of capture 2:K-1
i = i+1
result[i,1] = j
before = before + X[,j-1] # nr of captures before j
after = after - X[,j] # nr of captures after j
select = X[,j] & (after>0) # individuals recaptured at least once after j
ind = which(select) # rows of these individuals
nj = length(ind)
rest = (j+1):K # remaining occasions
restmj = 1:(K-j)
df = 0
drapeau = 0
U = rep(0,4)
if (nj > 0){
newORold = matrix(0,nrow=nj,ncol=2)
when = as.matrix(X[ind,rest]) # later recaptures of those captured in j
deja = rep(0,nj)
# restrict to next recaptured
for (ii in 1:nj){
for (jj in restmj){
deja[ii] = deja[ii] + when[ii,jj] # number of reobservations
if (deja[ii]>1) when[ii,jj] = 0 # if already seen again, neglect observation
} # loop on jj (remaining occasions)
} # loop on ii (selected individuals)
# end calculation of next recapture
effj = freq[ind] # works if eff is a columnn
aeffj = abs(effj) # handles negative numbers (if seen again after j)
newORold[,1] = (before[ind]>0)*aeffj # numbers of old by rh (nj x 2)
newORold[,2] = (before[ind]==0)*aeffj # numbers of new by rh
cont_tab = t(newORold) %*% when # (2 x nj by nj x K-j i.e. 2 by K-j
cont_tab = pool2K(cont_tab,2) # pool if needed
ML = apply(cont_tab,2,sum)
MC = apply(cont_tab,1,sum)
# calculate df
if (any(as.logical(cont_tab))){ # non empty table
df = (sum(ML>0)-1)*(sum(MC>0)-1) # takes account of empty rows and columns
} else {
df=0 # empty table
}
# end of df calculation
if (df>0) {
U = ind_test_rc(cont_tab,2)
} else {
U = c(0,0,0,'None')
}
} # if (nj > 0)
result[i,2] = U[1] # stat chi-square (also if Fisher performed)
result[i,3] = U[3] # degree of freedom
result[i,4] = U[2] # p-value of chi-square/Fisher
result[i,5] = U[4] # chi-square/Fisher
} # for (j in it3)
# compute overall test:
stat = sum(as.numeric(result[,2]))
stat = round(stat,rounding)
dof = sum(as.numeric(result[,3]))
pval = 1 - pchisq(stat,dof)
pval = round(pval,rounding)
# if user specifies all outputs
if (verbose==TRUE) return(list(test3sm=c(stat=stat,df=dof,p_val=pval),details=result))
# otherwise
if (verbose==FALSE) return(list(test3sm=c(stat=stat,df=dof,p_val=pval)))
n = dim(X)[1]
K = dim(X)[2]
result = data.frame(component = rep(NA,K-2),stat = rep(NA,K-2), df = rep(NA,K-2), p_val = rep(NA,K-2), test_perf = rep(FALSE,K-2))
it3 = 2:(K-1) # occasions of capture 2:K-1
before = rep(0,n) # nr of captures before 1
after = apply(X,1,sum)-X[,1] # nr of captures after 1
i = 0
for (j in it3){ # scan occasions of capture 2:K-1
i = i+1
result[i,1] = j
before = before + X[,j-1] # nr of captures before j
after = after - X[,j] # nr of captures after j
select = X[,j] & (after>0) # individuals recaptured at least once after j
ind = which(select) # rows of these individuals
nj = length(ind)
rest = (j+1):K # remaining occasions
restmj = 1:(K-j)
df = 0
drapeau = 0
U = rep(0,4)
if (nj > 0){
newORold = matrix(0,nrow=nj,ncol=2)
when = as.matrix(X[ind,rest]) # later recaptures of those captured in j
deja = rep(0,nj)
# restrict to next recaptured
for (ii in 1:nj){
for (jj in restmj){
deja[ii] = deja[ii] + when[ii,jj] # number of reobservations
if (deja[ii]>1) when[ii,jj] = 0 # if already seen again, neglect observation
} # loop on jj (remaining occasions)
} # loop on ii (selected individuals)
# end calculation of next recapture
effj = freq[ind] # works if eff is a columnn
aeffj = abs(effj) # handles negative numbers (if seen again after j)
newORold[,1] = (before[ind]>0)*aeffj # numbers of old by rh (nj x 2)
newORold[,2] = (before[ind]==0)*aeffj # numbers of new by rh
cont_tab = t(newORold) %*% when # (2 x nj by nj x K-j i.e. 2 by K-j
cont_tab = pool2K(cont_tab,2) # pool if needed
ML = apply(cont_tab,2,sum)
MC = apply(cont_tab,1,sum)
# calculate df
if (any(as.logical(cont_tab))){ # non empty table
df = (sum(ML>0)-1)*(sum(MC>0)-1) # takes account of empty rows and columns
} else {
df=0 # empty table
}
# end of df calculation
if (df>0) {
U = ind_test_rc(cont_tab,2)
} else {
U = c(0,0,0,'None')
}
} # if (nj > 0)
result[i,2] = U[1] # stat chi-square (also if Fisher performed)
result[i,3] = U[3] # degree of freedom
result[i,4] = U[2] # p-value of chi-square/Fisher
result[i,5] = U[4] # chi-square/Fisher
} # for (j in it3)
when
ii
jj
j
it3
n = dim(X)[1]
K = dim(X)[2]
result = data.frame(component = rep(NA,K-2),stat = rep(NA,K-2), df = rep(NA,K-2), p_val = rep(NA,K-2), test_perf = rep(FALSE,K-2))
it3 = 2:(K-1) # occasions of capture 2:K-1
before = rep(0,n) # nr of captures before 1
after = apply(X,1,sum)-X[,1] # nr of captures after 1
i = 0
j=3
i = i+1
i = i+1
result[i,1] = j
before = before + X[,j-1] # nr of captures before j
after = after - X[,j] # nr of captures after j
select = X[,j] & (after>0) # individuals recaptured at least once after j
ind = which(select) # rows of these individuals
nj = length(ind)
rest = (j+1):K # remaining occasions
restmj = 1:(K-j)
df = 0
drapeau = 0
U = rep(0,4)
newORold = matrix(0,nrow=nj,ncol=2)
when = as.matrix(X[ind,rest]) # later recaptures of those captured in j
deja = rep(0,nj)
# restrict to next recaptured
for (ii in 1:nj){
for (jj in restmj){
deja[ii] = deja[ii] + when[ii,jj] # number of reobservations
if (deja[ii]>1) when[ii,jj] = 0 # if already seen again, neglect observation
} # loop on jj (remaining occasions)
} # loop on ii (selected individuals)
nj
restmj
ind
rest
j
K
(j+1):K
1:(K-j)
when
rest
ii
jj
X[ind,rest]
matrix(X[ind,rest])
is.vector(X[ind,rest])
if (is.vector(X[ind,rest])){
when = matrix(X[ind,rest],ncol=length(X[ind,rest]))
} else {
when = as.matrix(X[ind,rest]) # later recaptures of those captured in j
}
when
deja = rep(0,nj)
# restrict to next recaptured
for (ii in 1:nj){
for (jj in restmj){
deja[ii] = deja[ii] + when[ii,jj] # number of reobservations
if (deja[ii]>1) when[ii,jj] = 0 # if already seen again, neglect observation
} # loop on jj (remaining occasions)
} # loop on ii (selected individuals)
devtools::build_vignettes()
library(R2ucare)
dipper
dipper = system.file("extdata", "wolf.inp", package = "R2ucare")
dipper = read_inp(dipper,group.df=data.frame(sex=c('Male','Female')))
dipper = system.file("extdata", "wolf.inp", package = "R2ucare")
dipper = read_inp(dipper)
dipper
dip.hist = dipper$encounter_histories
dip.freq = dipper$sample_size
?test3sm
test3sm(dip.hist, dip.freq)
test3sm()
test3sm
n = dim(X)[1]
K = dim(X)[2]
result = data.frame(component = rep(NA,K-2),stat = rep(NA,K-2), df = rep(NA,K-2), p_val = rep(NA,K-2), test_perf = rep(FALSE,K-2))
it3 = 2:(K-1) # occasions of capture 2:K-1
before = rep(0,n) # nr of captures before 1
after = apply(X,1,sum)-X[,1] # nr of captures after 1
i = 0
j=3
i=2
result[i,1] = j
before = before + X[,j-1] # nr of captures before j
after = after - X[,j] # nr of captures after j
select = X[,j] & (after>0) # individuals recaptured at least once after j
ind = which(select) # rows of these individuals
nj = length(ind)
rest = (j+1):K # remaining occasions
restmj = 1:(K-j)
df = 0
drapeau = 0
U = rep(0,4)
newORold = matrix(0,nrow=nj,ncol=2)
if (is.vector(X[ind,rest])){
when = matrix(X[ind,rest],ncol=length(X[ind,rest]))
} else {
when = as.matrix(X[ind,rest]) # later recaptures of those captured in j
}
deja = rep(0,nj)
when
# restrict to next recaptured
for (ii in 1:nj){
for (jj in restmj){
deja[ii] = deja[ii] + when[ii,jj] # number of reobservations
if (deja[ii]>1) when[ii,jj] = 0 # if already seen again, neglect observation
} # loop on jj (remaining occasions)
} # loop on ii (selected individuals)
# end calculation of next recapture
effj = freq[ind] # works if eff is a columnn
aeffj = abs(effj) # handles negative numbers (if seen again after j)
newORold[,1] = (before[ind]>0)*aeffj # numbers of old by rh (nj x 2)
newORold[,2] = (before[ind]==0)*aeffj # numbers of new by rh
cont_tab = t(newORold) %*% when # (2 x nj by nj x K-j i.e. 2 by K-j
cont_tab = pool2K(cont_tab,2) # pool if needed
ML = apply(cont_tab,2,sum)
MC = apply(cont_tab,1,sum)
# calculate df
if (any(as.logical(cont_tab))){ # non empty table
df = (sum(ML>0)-1)*(sum(MC>0)-1) # takes account of empty rows and columns
} else {
df=0 # empty table
}
# end of df calculation
if (df>0) {
U = ind_test_rc(cont_tab,2)
} else {
U = c(0,0,0,'None')
}
n = dim(X)[1]
K = dim(X)[2]
result = data.frame(component = rep(NA,K-2),stat = rep(NA,K-2), df = rep(NA,K-2), p_val = rep(NA,K-2), test_perf = rep(FALSE,K-2))
it3 = 2:(K-1) # occasions of capture 2:K-1
before = rep(0,n) # nr of captures before 1
after = apply(X,1,sum)-X[,1] # nr of captures after 1
i = 0
for (j in it3){ # scan occasions of capture 2:K-1
i = i+1
result[i,1] = j
before = before + X[,j-1] # nr of captures before j
after = after - X[,j] # nr of captures after j
select = X[,j] & (after>0) # individuals recaptured at least once after j
ind = which(select) # rows of these individuals
nj = length(ind)
rest = (j+1):K # remaining occasions
restmj = 1:(K-j)
df = 0
drapeau = 0
U = rep(0,4)
if (nj > 0){
newORold = matrix(0,nrow=nj,ncol=2)
if (is.vector(X[ind,rest])){
when = matrix(X[ind,rest],ncol=length(X[ind,rest]))
} else {
when = as.matrix(X[ind,rest]) # later recaptures of those captured in j
}
deja = rep(0,nj)
# restrict to next recaptured
for (ii in 1:nj){
for (jj in restmj){
deja[ii] = deja[ii] + when[ii,jj] # number of reobservations
if (deja[ii]>1) when[ii,jj] = 0 # if already seen again, neglect observation
} # loop on jj (remaining occasions)
} # loop on ii (selected individuals)
# end calculation of next recapture
effj = freq[ind] # works if eff is a columnn
aeffj = abs(effj) # handles negative numbers (if seen again after j)
newORold[,1] = (before[ind]>0)*aeffj # numbers of old by rh (nj x 2)
newORold[,2] = (before[ind]==0)*aeffj # numbers of new by rh
cont_tab = t(newORold) %*% when # (2 x nj by nj x K-j i.e. 2 by K-j
cont_tab = pool2K(cont_tab,2) # pool if needed
ML = apply(cont_tab,2,sum)
MC = apply(cont_tab,1,sum)
# calculate df
if (any(as.logical(cont_tab))){ # non empty table
df = (sum(ML>0)-1)*(sum(MC>0)-1) # takes account of empty rows and columns
} else {
df=0 # empty table
}
# end of df calculation
if (df>0) {
U = ind_test_rc(cont_tab,2)
} else {
U = c(0,0,0,'None')
}
} # if (nj > 0)
result[i,2] = U[1] # stat chi-square (also if Fisher performed)
result[i,3] = U[3] # degree of freedom
result[i,4] = U[2] # p-value of chi-square/Fisher
result[i,5] = U[4] # chi-square/Fisher
} # for (j in it3)
j
when
ind
rest
X[ind,rest]
when
ind
rest
nj
restmj
rest
ind
X[ind,rest]
n = dim(X)[1]
K = dim(X)[2]
result = data.frame(component = rep(NA,K-2),stat = rep(NA,K-2), df = rep(NA,K-2), p_val = rep(NA,K-2), test_perf = rep(FALSE,K-2))
it3 = 2:(K-1) # occasions of capture 2:K-1
before = rep(0,n) # nr of captures before 1
after = apply(X,1,sum)-X[,1] # nr of captures after 1
i = 0
for (j in it3){ # scan occasions of capture 2:K-1
i = i+1
result[i,1] = j
before = before + X[,j-1] # nr of captures before j
after = after - X[,j] # nr of captures after j
select = X[,j] & (after>0) # individuals recaptured at least once after j
ind = which(select) # rows of these individuals
nj = length(ind)
rest = (j+1):K # remaining occasions
restmj = 1:(K-j)
df = 0
drapeau = 0
U = rep(0,4)
if (nj > 0){
newORold = matrix(0,nrow=nj,ncol=2)
if (length(rest)==1){ when = matrix(X[ind,rest],nrow=length(X[ind,rest]))}
if (length(ind)==1){ when = matrix(X[ind,rest],ncol=length(X[ind,rest]))}
when = as.matrix(X[ind,rest]) # later recaptures of those captured in j
deja = rep(0,nj)
# restrict to next recaptured
for (ii in 1:nj){
for (jj in restmj){
deja[ii] = deja[ii] + when[ii,jj] # number of reobservations
if (deja[ii]>1) when[ii,jj] = 0 # if already seen again, neglect observation
} # loop on jj (remaining occasions)
} # loop on ii (selected individuals)
# end calculation of next recapture
effj = freq[ind] # works if eff is a columnn
aeffj = abs(effj) # handles negative numbers (if seen again after j)
newORold[,1] = (before[ind]>0)*aeffj # numbers of old by rh (nj x 2)
newORold[,2] = (before[ind]==0)*aeffj # numbers of new by rh
cont_tab = t(newORold) %*% when # (2 x nj by nj x K-j i.e. 2 by K-j
cont_tab = pool2K(cont_tab,2) # pool if needed
ML = apply(cont_tab,2,sum)
MC = apply(cont_tab,1,sum)
# calculate df
if (any(as.logical(cont_tab))){ # non empty table
df = (sum(ML>0)-1)*(sum(MC>0)-1) # takes account of empty rows and columns
} else {
df=0 # empty table
}
# end of df calculation
if (df>0) {
U = ind_test_rc(cont_tab,2)
} else {
U = c(0,0,0,'None')
}
} # if (nj > 0)
result[i,2] = U[1] # stat chi-square (also if Fisher performed)
result[i,3] = U[3] # degree of freedom
result[i,4] = U[2] # p-value of chi-square/Fisher
result[i,5] = U[4] # chi-square/Fisher
} # for (j in it3)
j
rest
ind
length(X[ind,rest])
matrix(X[ind,rest],ncol=length(X[ind,rest]))
n = dim(X)[1]
K = dim(X)[2]
result = data.frame(component = rep(NA,K-2),stat = rep(NA,K-2), df = rep(NA,K-2), p_val = rep(NA,K-2), test_perf = rep(FALSE,K-2))
it3 = 2:(K-1) # occasions of capture 2:K-1
before = rep(0,n) # nr of captures before 1
after = apply(X,1,sum)-X[,1] # nr of captures after 1
i = 0
for (j in it3){ # scan occasions of capture 2:K-1
i = i+1
result[i,1] = j
before = before + X[,j-1] # nr of captures before j
after = after - X[,j] # nr of captures after j
select = X[,j] & (after>0) # individuals recaptured at least once after j
ind = which(select) # rows of these individuals
nj = length(ind)
rest = (j+1):K # remaining occasions
restmj = 1:(K-j)
df = 0
drapeau = 0
U = rep(0,4)
if (nj > 0){
newORold = matrix(0,nrow=nj,ncol=2)
if (length(rest)==1){ when = matrix(X[ind,rest],nrow=length(X[ind,rest]))}
if (length(ind)==1){ when = matrix(X[ind,rest],ncol=length(X[ind,rest]))}
if ((length(rest)!=1)&(length(ind)!=1)) {when = as.matrix(X[ind,rest])} # later recaptures of those captured in j
deja = rep(0,nj)
# restrict to next recaptured
for (ii in 1:nj){
for (jj in restmj){
deja[ii] = deja[ii] + when[ii,jj] # number of reobservations
if (deja[ii]>1) when[ii,jj] = 0 # if already seen again, neglect observation
} # loop on jj (remaining occasions)
} # loop on ii (selected individuals)
# end calculation of next recapture
effj = freq[ind] # works if eff is a columnn
aeffj = abs(effj) # handles negative numbers (if seen again after j)
newORold[,1] = (before[ind]>0)*aeffj # numbers of old by rh (nj x 2)
newORold[,2] = (before[ind]==0)*aeffj # numbers of new by rh
cont_tab = t(newORold) %*% when # (2 x nj by nj x K-j i.e. 2 by K-j
cont_tab = pool2K(cont_tab,2) # pool if needed
ML = apply(cont_tab,2,sum)
MC = apply(cont_tab,1,sum)
# calculate df
if (any(as.logical(cont_tab))){ # non empty table
df = (sum(ML>0)-1)*(sum(MC>0)-1) # takes account of empty rows and columns
} else {
df=0 # empty table
}
# end of df calculation
if (df>0) {
U = ind_test_rc(cont_tab,2)
} else {
U = c(0,0,0,'None')
}
} # if (nj > 0)
result[i,2] = U[1] # stat chi-square (also if Fisher performed)
result[i,3] = U[3] # degree of freedom
result[i,4] = U[2] # p-value of chi-square/Fisher
result[i,5] = U[4] # chi-square/Fisher
} # for (j in it3)
devtools::build_vignettes()
library(R2ucare)
devtools::build_vignettes()
library(R2ucare)
X
eff
freq
test3sm(dip.hist, dip.freq)
dipper = system.file("extdata", "wolf.inp", package = "R2ucare")
dipper = read_inp(dipper)
dip.hist = dipper$encounter_histories
dip.freq = dipper$sample_size
test3sm(dip.hist, dip.freq)
devtools::build_vignettes()
library(R2ucare)
