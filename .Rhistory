nk = nrow(mixandbases)
mixandbases
if (any(apply(tabtemp,1,sum)==0) | (nj==0)){
table_multi_mitec[i-1,1] = i
table_multi_mitec[i-1,2] = 0
table_multi_mitec[i-1,3] = 0
table_multi_mitec[i-1,4] = 0
table_multi_mitec[i-1,5] = 'None'
break
}
apply(tabtemp,1,sum)
mixandbases = pooling_mixtures(nk,nj,a,mixandbases)
mixandbases
indic_mixbasis = c(matrix(0,nrow=nrow(mixandbases)-nj,ncol=1),rep(1,nj)) # indique 1 ou 0 suivant que base ou melange
data = cbind(mixandbases,indic_mixbasis)
#if verbosity>=3
#    strtable=[ strtable {strcat('occasion :',num2str(i))} ];
#    taille=size(data,2);
#    strtable=[ strtable {'--------------- Seen again - Seen again later '} ];
#    for kk=1:size(data,1)
#        if data(kk,taille)==0
#            strtable=[ strtable {strcat('When last released | ',num2str(data(kk,1:taille-1))) }];
#        else
#            strtable=[ strtable {strcat('Currently released | ',num2str(data(kk,1:taille-1))) }];
#        end
#    end
#end
nk = nrow(data)
r = ncol(data)
ni = r - 1
data = t(data)
nature = data[r,] # il s'agit de indic_mixanbasis'
data = data[-r,] # on la supprime !!!
tri = which(nature!=0) # coordonnees des bases
nj = length(tri) # nombre de bases
tri = c(tri,which(nature==0)) # ajout des coordonnees des melanges
M = data[,tri] # on renumerote bases et melanges
totk = apply(M,2,sum) # effectif des colonnes
CoorMelVide = which(totk[(nj+1):nk]==0)
if (!(length(CoorMelVide)==0)) M = M[,-CoorMelVide]
nk = ncol(M)
totk = apply(M,2,sum) # actualisation des effectifs des colonnes
# Si aucune base n'est vide & si melanges
if (nj!=nk){
# NEW definition des bases
Np = t(M[,1:nj])
# definition des melanges
Mp = t(M[,(nj+1):nk])
# calcul des coefficients du melanges
res = coef_mixtures(Mp,Np)
Q = res$P
P = res$PI
A = res$GAM
Q = rbind(P,Q)
# calcul des valeurs attendues
theoriques = matrix(rep(totk,ni),byrow=T,nrow=ni) * t(Q)
# calcul du nombre de degres de liberte
df = (nk-nj)*(ni-nj)
# test LR
tempchi2 = gof_test(1,c(M),c(theoriques))
table_multi_mitec[i-1,1] = i
table_multi_mitec[i-1,2] = tempchi2
table_multi_mitec[i-1,3] = df
table_multi_mitec[i-1,4] = 1-pchisq(tempchi2,df)
table_multi_mitec[i-1,5] = 'Chi-square'
} else {
table_multi_mitec[i-1,1] = i
table_multi_mitec[i-1,2] = 0
table_multi_mitec[i-1,3] = 0
table_multi_mitec[i-1,4] = 0
table_multi_mitec[i-1,5] = 'None'
}
}
# compute overall test:
stat = sum(as.numeric(table_multi_mitec[,2]))
table_multi_mitec
k
i=3
mixandbases = datat[debutligne:finligne[i],debutcolonne[i]:fincolonne]
mixandbases
for (j in 1:(i-2)){
if ((i-2)<1) break
mixandbases[1:a,] = mixandbases[1:a,] + mixandbases[(a+1):(2*a),]
mixandbases = mixandbases[-((a+1):(2*a)),]
}
for (j in 1:((ncol(mixandbases)-a)/a-1)){
if (((ncol(mixandbases)-a)/a-1)<1) break
mixandbases[,(a+1):(2*a)] = mixandbases[,(a+1):(2*a)] + mixandbases[,(2*a+1):(3*a)]
mixandbases = mixandbases[,-((2*a+1):(3*a))]
}
nk = nrow(mixandbases)
tabtemp = mixandbases[(nk-a+1):nk,]
#tabtemp = tabtemp[filtre,] # les bases filtrees
mixandbases = rbind(mixandbases[1:(nk-a),],tabtemp)
nj = nrow(tabtemp)
nk = nrow(mixandbases)
mixandbases
if (any(apply(tabtemp,1,sum)==0) | (nj==0)){
table_multi_mitec[i-1,1] = i
table_multi_mitec[i-1,2] = 0
table_multi_mitec[i-1,3] = 0
table_multi_mitec[i-1,4] = 0
table_multi_mitec[i-1,5] = 'None'
break
}
install.packages("revealjs", type = "source")
geese = system.file("extdata", "geese.inp", package = "R2ucare")
geese = read_inp(geese)
geese.hist = geese$encounter_histories
geese.freq = geese$sample_size
test3Gwbwa(geese.hist,geese.freq)
test3Gsr(geese.hist,geese.freq)
test3Gsm(geese.hist,geese.freq)
testMitec(geese.hist,geese.freq)
testMltec(geese.hist,geese.freq)
library(R2ucare)
geese = system.file("extdata", "geese.inp", package = "R2ucare")
geese = read_inp(geese)
geese.hist = geese$encounter_histories
geese.freq = geese$sample_size
test3Gwbwa(geese.hist,geese.freq)
test3Gsr(geese.hist,geese.freq)
test3Gsm(geese.hist,geese.freq)
testMitec(geese.hist,geese.freq)
testMltec(geese.hist,geese.freq)
test3Gsm(geese.hist,geese.freq)
verbose=TRUE
rounding=3
X=geese.hist,freq=geese.freq
X=geese.hist;freq=geese.freq
# various quantities to define
k = ncol(X)
res = group_data(X,freq)
his = res[,1:k]
eff = res[,k+1]
nh = nrow(his)
a = max(his)
ns = a
kplusun = k + 1
# initialization
table_multi_3sm = data.frame(occasion = rep(NA,a*(k-2)),site = rep(NA,a*(k-2)),stat = rep(NA,a*(k-2)), df = rep(NA,a*(k-2)), p_val = rep(NA,a*(k-2)), test_perf = rep(FALSE,a*(k-2)))
where_in_table_3sm = 0
#nsitereel=sum(filtre)
stattotal = NULL
i=2
l=1
where_in_table_3sm = where_in_table_3sm + 1
#if filtre(l)
fisheroupas=0
masque = (his[,i]==l)
batch = his[masque,] # select encounter histories containing l in column i
if (length(batch)==0){ # if no release at date i on site l, no test
table_multi_3sm[where_in_table_3sm,1] = i
table_multi_3sm[where_in_table_3sm,2] = l
table_multi_3sm[where_in_table_3sm,3] = 0
table_multi_3sm[where_in_table_3sm,4] = 0
table_multi_3sm[where_in_table_3sm,5] = 0
table_multi_3sm[where_in_table_3sm,6] = 'None'
next
}
batcheff = eff[masque] # select counts corresponding to encounter histories with l in column i
res = group_data_gen(batch,batcheff,(i+1):k) # sort according to columns i+1,...,k
batchpost = res[,1:ncol(res)-1]
batcheffpost = res[,ncol(res)]
# look site on which previous obs occurred
if (i!=2){
tt = t(apply(batchpost[,1:(i-1)],1,rev))
eante = apply(tt!=0,1,which.max)
eante = i - eante
} else {
eante = rep(1,nrow(batchpost))
}
# on cherche le site d'observation suivant
if (i!=(k-1)){
epost = apply(batchpost[,(i+1):k]!=0,1,which.max)
} else {
epost = rep(1,nrow(batchpost))
}
# build table of obs at date i on site l in rows
# according to site of previous obs and in columns
# according to site and date of next obs
# PS: on first row, never seen before
#     on last column, never seen again
j = 0
ind = (k-i)*a+1
table = matrix(0,nrow=a+1,ncol=ind)
cpt = matrix(0,nrow=a+1,ncol=1)
while (j<nrow(batchpost)){ # go through encounter histories
j=j+1
date = epost[j]
site = batchpost[j,i+date]
if (site==0){
col = ind # never seen again
} else{
col = (date-1)*a+site # seen again at date and site
}
if (j==1){
cold = col
} else if (col!=cold){
table[,cold] = cpt
cpt = matrix(0,nrow=a+1,ncol=1)
cold = col
}
tempo = batchpost[j,eante[j]] + 1 # site of previous obs + 1
if (site==0){
cpt[tempo] = cpt[tempo] + batcheffpost[j] * (batcheffpost[j]>0)
} else {
cpt[tempo]=cpt[tempo]+abs(batcheffpost[j])
}
}
table[,cold] = cpt #
table
table1 = table[1,1:(ncol(table)-1)]
table2 = table[1,ncol(table)]
tablerevu = table[2:(1+ns),1:(ncol(table)-1)]
table4 = table[2:(1+ns),ncol(table)]
#   affichage des tables au fur et a mesure de leur creation
table = rbind(table1,apply(tablerevu,2,sum))
table
((nrow(table)*ncol(table))
>=4
)
((nrow(table)*ncol(table))>=4)
table = pooling_ct(table)
table
(any(expval_table(table)<2))
old.warn <- options()$warn # to suppress the warning messages
options(warn = -1)
chi2 = chisq.test(table,correct=F)
options(warn = old.warn)
pvalchi2 = chi2$p.value
dfchi2 = chi2$parameter
stachi2 = chi2$statistic
table_multi_3sm[where_in_table_3sm,1] = i
table_multi_3sm[where_in_table_3sm,2] = l
table_multi_3sm[where_in_table_3sm,3] = stachi2
table_multi_3sm[where_in_table_3sm,4] = dfchi2
table_multi_3sm[where_in_table_3sm,5] = pvalchi2
table_multi_3sm[where_in_table_3sm,6] = 'Chi-square'
dfchi2
ns>1
table = cbind(apply(tablerevu,1,sum),table4)
table
((nrow(table)*ncol(table))>=4)
table = pooling_ct(table)
table
(any(expval_table(table)<2))
old.warn <- options()$warn # to suppress the warning messages
options(warn = -1)
chi2 = chisq.test(table,correct=F)
options(warn = old.warn)
pvalchi2 = chi2$p.value
dfchi2 = chi2$parameter
stachi2 = chi2$statistic
table_multi_3sm[where_in_table_3sm,1] = i
table_multi_3sm[where_in_table_3sm,2] = l
table_multi_3sm[where_in_table_3sm,3] = stachi2 + table_multi_3sm[where_in_table_3sm,3]
table_multi_3sm[where_in_table_3sm,4] = dfchi2 + table_multi_3sm[where_in_table_3sm,4]
table_multi_3sm[where_in_table_3sm,5] = pvalchi2 + table_multi_3sm[where_in_table_3sm,5]
table_multi_3sm[where_in_table_3sm,6] = 'Chi-square'
#           if verbosity>=3
#               strtable=[ strtable {strcat('Associated test of the last table :',num2str(chi2(table)))} ];
#           end
dfchi2
dfchi2
ns
j=1
table = tablerevu[,seq(j,ncol(tablerevu),by=ns)]
table
if (is.null(dim(table))) {table=as.matrix(table)} # if table is a vector
table
((nrow(table)*ncol(table))>=4)
table = pooling_ct(table)
(any(expval_table(table)<2))
old.warn <- options()$warn # to suppress the warning messages
options(warn = -1)
chi2 = chisq.test(table,correct=F)
options(warn = old.warn)
pvalchi2 = chi2$p.value
dfchi2 = chi2$parameter
stachi2 = chi2$statistic
dfchi2
j=2
table = tablerevu[,seq(j,ncol(tablerevu),by=ns)]
if (is.null(dim(table))) {table=as.matrix(table)} # if table is a vector
table
((nrow(table)*ncol(table))>=4)
table = pooling_ct(table)
(any(expval_table(table)<2))
old.warn <- options()$warn # to suppress the warning messages
options(warn = -1)
chi2 = chisq.test(table,correct=F)
options(warn = old.warn)
pvalchi2 = chi2$p.value
dfchi2 = chi2$parameter
stachi2 = chi2$statistic
dfchi2
j=3
table = tablerevu[,seq(j,ncol(tablerevu),by=ns)]
if (is.null(dim(table))) {table=as.matrix(table)} # if table is a vector
((nrow(table)*ncol(table))>=4)
table = pooling_ct(table)
table
(any(expval_table(table)<2))
fish = fisher.test(table)
pvalfish = fish$p.value
dffish = (nrow(table)-1)*(ncol(table)-1)
stafish = qchisq(1-pvalfish, dffish)
dffish
table
c(apply(table,1,sum),apply(table,2,sum))
any(c(apply(table,1,sum),apply(table,2,sum)))
all(c(apply(table,1,sum),apply(table,2,sum)))
c(apply(table,1,sum),apply(table,2,sum))==0
sum(c(apply(table,1,sum),apply(table,2,sum))==0)>0
qchisq(1-0.5, dffish)
dffish
qchisq(1-0.5, 0)
(sum(c(apply(table,1,sum),apply(table,2,sum))==0)>0)
zeros_rows = (apply(table,1,sum)==0)
zeros_cols = (apply(table,2,sum)==0)
zeros_rows
zeros_cols
sum(zeros_rows)
sum(!zeros_rows)
library("devtools")
install_github('oliviergimenez/R2ucare')
test3Gsm(geese.hist,geese.freq)
library("devtools")
@
install_github('oliviergimenez/R2ucare')
test3Gwbwa(geese.hist,geese.freq)
geese = system.file("extdata", "sooty.inp", package = "R2ucare")
geese = read_inp(geese)
geese.hist = geese$encounter_histories
geese.freq = geese$sample_size
test3Gwbwa(geese.hist,geese.freq)
test3Gsr(geese.hist,geese.freq)
test3Gsm(geese.hist,geese.freq)
testMitec(geese.hist,geese.freq)
testMltec(geese.hist,geese.freq)
verbose
rounding
X=geese.hist
freq=geese.freq
k = ncol(X)
his = X
a = max(his)
# initialization
table_multi_mitec = data.frame(occasion = rep(NA,k-3),stat = rep(NA,k-3), df = rep(NA,k-3), p_val = rep(NA,k-3), test_perf = rep(FALSE,k-3))
marray = multimarray(X,freq)
debutligne = 1
finligne = seq(a,a*k,by=a)
debutcolonne = seq(1,a*(k-1),by=a)
fincolonne = a * (k-1)
datat = marray[,2:(ncol(marray)-1)] # extrait du m-array avec les revus, sans les relaches ni les jamais revus
k
i=5
mixandbases = datat[debutligne:finligne[i],debutcolonne[i]:fincolonne]
for (j in 1:(i-2)){
if ((i-2)<1) break
mixandbases[1:a,] = mixandbases[1:a,] + mixandbases[(a+1):(2*a),]
mixandbases = mixandbases[-((a+1):(2*a)),]
}
for (j in 1:((ncol(mixandbases)-a)/a-1)){
if (((ncol(mixandbases)-a)/a-1)<1) break
mixandbases[,(a+1):(2*a)] = mixandbases[,(a+1):(2*a)] + mixandbases[,(2*a+1):(3*a)]
mixandbases = mixandbases[,-((2*a+1):(3*a))]
}
nk = nrow(mixandbases)
tabtemp = mixandbases[(nk-a+1):nk,]
#tabtemp = tabtemp[filtre,] # les bases filtrees
mixandbases = rbind(mixandbases[1:(nk-a),],tabtemp)
nj = nrow(tabtemp)
nk = nrow(mixandbases)
if (any(apply(tabtemp,1,sum)==0) | (nj==0)){
table_multi_mitec[i-1,1] = i
table_multi_mitec[i-1,2] = 0
table_multi_mitec[i-1,3] = 0
table_multi_mitec[i-1,4] = 0
table_multi_mitec[i-1,5] = 'None'
break
}
# pooling
mixandbases = pooling_mixtures(nk,nj,a,mixandbases)
# DEBUT DU CALCUL DU TEST DE MELANGE (traduit de Yantis et al)
indic_mixbasis = c(matrix(0,nrow=nrow(mixandbases)-nj,ncol=1),rep(1,nj)) # indique 1 ou 0 suivant que base ou melange
data = cbind(mixandbases,indic_mixbasis)
#if verbosity>=3
#    strtable=[ strtable {strcat('occasion :',num2str(i))} ];
#    taille=size(data,2);
#    strtable=[ strtable {'--------------- Seen again - Seen again later '} ];
#    for kk=1:size(data,1)
#        if data(kk,taille)==0
#            strtable=[ strtable {strcat('When last released | ',num2str(data(kk,1:taille-1))) }];
#        else
#            strtable=[ strtable {strcat('Currently released | ',num2str(data(kk,1:taille-1))) }];
#        end
#    end
#end
nk = nrow(data)
r = ncol(data)
ni = r - 1
data = t(data)
nature = data[r,] # il s'agit de indic_mixanbasis'
data = data[-r,] # on la supprime !!!
tri = which(nature!=0) # coordonnees des bases
nj = length(tri) # nombre de bases
tri = c(tri,which(nature==0)) # ajout des coordonnees des melanges
M = data[,tri] # on renumerote bases et melanges
totk = apply(M,2,sum) # effectif des colonnes
CoorMelVide = which(totk[(nj+1):nk]==0)
if (!(length(CoorMelVide)==0)) M = M[,-CoorMelVide]
nk = ncol(M)
totk = apply(M,2,sum) # actualisation des effectifs des colonnes
# Si aucune base n'est vide & si melanges
if (nj!=nk){
# NEW definition des bases
Np = t(M[,1:nj])
# definition des melanges
Mp = t(M[,(nj+1):nk])
# calcul des coefficients du melanges
res = coef_mixtures(Mp,Np)
Q = res$P
P = res$PI
A = res$GAM
Q = rbind(P,Q)
# calcul des valeurs attendues
theoriques = matrix(rep(totk,ni),byrow=T,nrow=ni) * t(Q)
# calcul du nombre de degres de liberte
df = (nk-nj)*(ni-nj)
# test LR
tempchi2 = gof_test(1,c(M),c(theoriques))
table_multi_mitec[i-1,1] = i
table_multi_mitec[i-1,2] = tempchi2
table_multi_mitec[i-1,3] = df
table_multi_mitec[i-1,4] = 1-pchisq(tempchi2,df)
table_multi_mitec[i-1,5] = 'Chi-square'
} else {
table_multi_mitec[i-1,1] = i
table_multi_mitec[i-1,2] = 0
table_multi_mitec[i-1,3] = 0
table_multi_mitec[i-1,4] = 0
table_multi_mitec[i-1,5] = 'None'
}
res = coef_mixtures(Mp,Np)
res
Q = res$P
P = res$PI
A = res$GAM
Q = rbind(P,Q)
# calcul des valeurs attendues
theoriques = matrix(rep(totk,ni),byrow=T,nrow=ni) * t(Q)
theoriques
df = (nk-nj)*(ni-nj)
tempchi2 = gof_test(1,c(M),c(theoriques))
tempchi2
c(M)
c(theoriques)
df
freq
X
Mp
Np
ni
totk
nk
nj
df
theoriques2=matrix(c(  67.3015,   19.6628,   74.5452 ,  16.7830,
1.1204,   74.4341 ,   1.9222 ,  63.1939,
5.3580,    4.3468 ,   5.9603,    3.6975,
3.2201,    1.5564 ,   3.5723 ,   1.3256),byrow=T,nrow=4)
theoriques
theoriques2
tempchi2_bis = gof_test(1,c(M),c(theoriques))
tempchi2_bis
tempchi2_ter = gof_test(1,c(M),c(theoriques2))
tempchi2_ter
install_github('oliviergimenez/R2ucare')
testMitec(geese.hist,geese.freq)
testMltec(geese.hist,geese.freq)
install_github('oliviergimenez/R2ucare')
testMitec(geese.hist,geese.freq)
testMltec(geese.hist,geese.freq)
Np
Mp
coef_mixtures(Mp,Np)
# various quantities to be defined
M = Mp
N = Np
s = nrow(N) # s = nb of bases
n = ncol(N)
nbmel = nrow(M) # nb of mixtures
dim(M) = c(1,nbmel*n)
dim(N) = c(1,s*n)
# initial values
x = matrix(0.1,nrow=nbmel*(s-1)+s*(n-1),ncol=1)
# Minimization
tmpmin = optim(x,deviance_mixture,NULL,hessian=FALSE,M,N,s,n,nbmel,method="BFGS",control=list(trace=0, reltol=.0000001
,abstol=.000001))
tmpmin
464.158*2
geese = system.file("extdata", "geese.inp", package = "R2ucare")
geese = read_inp(geese)
geese.hist = geese$encounter_histories
geese.freq = geese$sample_size
test3Gwbwa(geese.hist,geese.freq)
test3Gsr(geese.hist,geese.freq)
test3Gsm(geese.hist,geese.freq)
testMitec(geese.hist,geese.freq)
testMltec(geese.hist,geese.freq)
